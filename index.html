<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yahtzee Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f8ff;
        }

        .game-container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }

        .game-info {
            text-align: center;
            margin-bottom: 30px;
            font-size: 18px;
            color: #34495e;
        }

        .dice-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .die {
            width: 80px;
            height: 80px;
            border: 3px solid #3498db;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: bold;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }

        .die:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .die.held {
            background: #e74c3c;
            color: white;
            border-color: #c0392b;
        }

        .die.suggested {
            background: #f39c12;
            color: white;
            border-color: #e67e22;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(243, 156, 18, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(243, 156, 18, 0); }
            100% { box-shadow: 0 0 0 0 rgba(243, 156, 18, 0); }
        }

        .die.rolling {
            animation: roll 0.8s ease-in-out;
        }

        @keyframes roll {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(0.9); }
            75% { transform: rotate(270deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .die.shake {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
            20%, 40%, 60%, 80% { transform: translateX(3px); }
        }

        .controls {
            text-align: center;
            margin: 30px 0;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 10px;
            transition: background 0.3s ease;
        }

        button:hover:not(:disabled) {
            background: #2980b9;
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .instructions {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .final-result {
            background: #d5f4e6;
            border: 2px solid #27ae60;
            padding: 20px;
            border-radius: 5px;
            margin-top: 20px;
            text-align: center;
        }

        .final-result h3 {
            color: #27ae60;
            margin-top: 0;
        }

        .dice-values {
            font-size: 18px;
            margin: 10px 0;
        }

        .hints {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            text-align: center;
        }

        .hints h4 {
            color: #856404;
            margin-top: 0;
        }

        .hint-suggestion {
            color: #495057;
            font-weight: bold;
        }

        .fireworks {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .firework {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: firework 2s ease-out forwards;
            box-shadow: 0 0 10px currentColor;
        }

        @keyframes firework {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
                box-shadow: 0 0 20px currentColor;
            }
            50% {
                transform: translate(calc(var(--dx) * 0.7), calc(var(--dy) * 0.7)) scale(1.5);
                opacity: 0.8;
            }
            100% {
                transform: translate(var(--dx), var(--dy)) scale(0);
                opacity: 0;
                box-shadow: 0 0 0px currentColor;
            }
        }

        .firework:nth-child(1) { background: #ff6b6b; color: #ff6b6b; --dx: 200px; --dy: -300px; animation-delay: 0s; }
        .firework:nth-child(2) { background: #4ecdc4; color: #4ecdc4; --dx: -250px; --dy: -200px; animation-delay: 0.05s; }
        .firework:nth-child(3) { background: #45b7d1; color: #45b7d1; --dx: 180px; --dy: -400px; animation-delay: 0.1s; }
        .firework:nth-child(4) { background: #f9ca24; color: #f9ca24; --dx: -180px; --dy: -350px; animation-delay: 0.15s; }
        .firework:nth-child(5) { background: #f0932b; color: #f0932b; --dx: 300px; --dy: -250px; animation-delay: 0.2s; }
        .firework:nth-child(6) { background: #eb4d4b; color: #eb4d4b; --dx: -300px; --dy: -320px; animation-delay: 0.25s; }
        .firework:nth-child(7) { background: #6c5ce7; color: #6c5ce7; --dx: 250px; --dy: -180px; animation-delay: 0.3s; }
        .firework:nth-child(8) { background: #a29bfe; color: #a29bfe; --dx: -200px; --dy: -450px; animation-delay: 0.35s; }
        .firework:nth-child(9) { background: #fd79a8; color: #fd79a8; --dx: 150px; --dy: -280px; animation-delay: 0.4s; }
        .firework:nth-child(10) { background: #00b894; color: #00b894; --dx: -150px; --dy: -200px; animation-delay: 0.45s; }
        .firework:nth-child(11) { background: #ff7675; color: #ff7675; --dx: 350px; --dy: -150px; animation-delay: 0.5s; }
        .firework:nth-child(12) { background: #74b9ff; color: #74b9ff; --dx: -350px; --dy: -250px; animation-delay: 0.55s; }
        .firework:nth-child(13) { background: #55a3ff; color: #55a3ff; --dx: 120px; --dy: -500px; animation-delay: 0.6s; }
        .firework:nth-child(14) { background: #fd79a8; color: #fd79a8; --dx: -120px; --dy: -180px; animation-delay: 0.65s; }
        .firework:nth-child(15) { background: #fdcb6e; color: #fdcb6e; --dx: 280px; --dy: -380px; animation-delay: 0.7s; }
        .firework:nth-child(16) { background: #e17055; color: #e17055; --dx: -280px; --dy: -420px; animation-delay: 0.75s; }
        .firework:nth-child(17) { background: #00b894; color: #00b894; --dx: 400px; --dy: -300px; animation-delay: 0.8s; }
        .firework:nth-child(18) { background: #00cec9; color: #00cec9; --dx: -400px; --dy: -150px; animation-delay: 0.85s; }
        .firework:nth-child(19) { background: #6c5ce7; color: #6c5ce7; --dx: 50px; --dy: -600px; animation-delay: 0.9s; }
        .firework:nth-child(20) { background: #a29bfe; color: #a29bfe; --dx: -50px; --dy: -100px; animation-delay: 0.95s; }

        .yahtzee-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4em;
            font-weight: bold;
            color: #f39c12;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 1001;
            animation: yahtzee-bounce 2s ease-in-out;
            pointer-events: none;
        }

        @keyframes yahtzee-bounce {
            0%, 20%, 50%, 80%, 100% { transform: translate(-50%, -50%) translateY(0); }
            40% { transform: translate(-50%, -50%) translateY(-30px); }
            60% { transform: translate(-50%, -50%) translateY(-15px); }
        }

        .scorecard-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 300px;
        }

        .scorecard-container h3 {
            text-align: center;
            color: #2c3e50;
            margin-top: 0;
        }

        .scorecard {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        .scorecard th {
            background: #3498db;
            color: white;
            padding: 8px;
            text-align: center;
        }

        .scorecard td {
            padding: 6px 8px;
            border-bottom: 1px solid #ecf0f1;
        }

        .scorecard .score-cell {
            text-align: center;
            font-weight: bold;
            width: 60px;
        }

        .scorecard tr.upper-section,
        .scorecard tr.lower-section {
            background: #f8f9fa;
        }

        .scorecard tr.subtotal,
        .scorecard tr.bonus,
        .scorecard tr.total {
            background: #e8f4fd;
            border-top: 2px solid #3498db;
        }

        .scorecard tr[data-category]:hover {
            background: #f0f8ff;
            cursor: pointer;
        }

        .scorecard tr[data-category].filled {
            background: #d5f4e6;
        }

        .scorecard tr[data-category].current-turn {
            background: #fff3cd;
            border: 2px solid #ffc107;
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .game-area {
            flex: 1;
            min-width: 400px;
        }

        .scorecards-container {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .player-scorecard {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 280px;
            min-width: 250px;
        }

        .player-scorecard.active-player {
            border: 3px solid #3498db;
            box-shadow: 0 6px 12px rgba(52, 152, 219, 0.3);
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .player-name {
            font-weight: bold;
            color: #2c3e50;
        }

        .player-status {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            background: #ecf0f1;
        }

        .player-status.playing {
            background: #3498db;
            color: white;
        }

        .ai-reasoning {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #17a2b8;
        }

        .ai-reasoning h4 {
            margin-top: 0;
            color: #17a2b8;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .reasoning-content {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #dee2e6;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }

        .reasoning-entry {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .reasoning-entry:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .reasoning-player {
            font-weight: bold;
            color: #495057;
            margin-bottom: 5px;
        }

        .reasoning-action {
            color: #6c757d;
            font-size: 14px;
            margin-bottom: 3px;
        }

        .reasoning-text {
            color: #28a745;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-area">
            <h1>ðŸŽ² Yahtzee Game ðŸŽ²</h1>
            
            <div class="instructions">
                <strong>How to play:</strong>
                <ul>
                    <li>Click "Roll Dice" to start</li>
                    <li>Click on dice to hold them (they'll turn red)</li>
                    <li>You get 3 rolls per round</li>
                    <li>Try to get the best combination!</li>
                </ul>
            </div>

            <div class="game-info">
                <div id="turn-info">Click "New Game" to start!</div>
            </div>

            <div class="dice-container" id="dice-container">
                <div class="die" id="die-0">?</div>
                <div class="die" id="die-1">?</div>
                <div class="die" id="die-2">?</div>
                <div class="die" id="die-3">?</div>
                <div class="die" id="die-4">?</div>
            </div>

            <div class="controls">
                <button id="roll-btn" onclick="rollDice()">Roll Dice</button>
                <button id="new-game-btn" onclick="newGame()">New Game</button>
                <button id="auto-play-btn" onclick="startAutoPlay()">ðŸ§  GPT-4 vs AI Battle</button>
            </div>

            <div id="hints" class="hints" style="display: none;">
                <h4>ðŸ’¡ Suggestion</h4>
                <div id="hint-text" class="hint-suggestion"></div>
            </div>

            <div id="final-result" class="final-result" style="display: none;">
                <h3>ðŸŽ‰ Round Complete! ðŸŽ‰</h3>
                <div id="final-dice" class="dice-values"></div>
                <div id="sorted-dice" class="dice-values"></div>
            </div>

            <div id="ai-reasoning" class="ai-reasoning" style="display: none;">
                <h4>ðŸ§  AI Reasoning</h4>
                <div id="reasoning-content" class="reasoning-content"></div>
            </div>
        </div>

        <div class="scorecards-container" id="scorecards-container">
            <!-- Player scorecards will be dynamically generated here -->
        </div>
    </div>

    <script>
        class YahtzeePlayer {
            constructor(id, name, strategy = 'balanced', color = '#3498db') {
                this.id = id;
                this.name = name;
                this.strategy = strategy;
                this.color = color;
                this.scorecard = {};
                this.currentRound = 0;
                this.maxRounds = 13;
            }
        }

        class YahtzeeGame {
            constructor() {
                this.dice = [0, 0, 0, 0, 0];
                this.heldDice = [false, false, false, false, false];
                this.turn = 0;
                this.maxTurns = 3;
                this.gameStarted = false;
                this.suggestedDice = [false, false, false, false, false];
                this.diceEmoji = ['', 'ðŸŽ²', 'ðŸŽ²', 'ðŸŽ²', 'ðŸŽ²', 'ðŸŽ²', 'ðŸŽ²'];
                this.isAutoPlaying = false;
                
                // OpenAI API configuration
                this.openaiApiKey = null; // Will be set by user
                this.useLLM = false; // Toggle for LLM vs traditional AI
                
                // Multi-player setup
                this.players = [
                    new YahtzeePlayer(0, 'ðŸ§  GPT-4 Sam', 'llm-strategic', '#3498db'),
                    new YahtzeePlayer(1, 'ðŸ¤– GPT-4 Rita', 'llm-aggressive', '#e74c3c'),
                    new YahtzeePlayer(2, 'ðŸ’­ GPT-4 Carl', 'llm-conservative', '#27ae60'),
                    new YahtzeePlayer(3, 'ðŸŽª Wild Wendy', 'random', '#f39c12') // Keep one traditional AI for comparison
                ];
                this.currentPlayerIndex = 0;
                this.currentRound = 0;
                this.maxRounds = 13;
                
                this.initializeScoreCards();
                this.setupAPIKeyInput();
            }

            setupAPIKeyInput() {
                // Add API key input to the controls
                const controls = document.querySelector('.controls');
                const apiKeyContainer = document.createElement('div');
                apiKeyContainer.innerHTML = `
                    <div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                        <label for="api-key-input" style="display: block; margin-bottom: 5px; font-weight: bold;">
                            ðŸ§  OpenAI API Key (for GPT-4 players):
                        </label>
                        <input type="password" id="api-key-input" placeholder="sk-..." 
                               style="width: 300px; padding: 5px; margin-right: 10px; border: 1px solid #ddd; border-radius: 3px;">
                        <button onclick="game.setApiKey()" style="padding: 5px 10px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer;">
                            Enable GPT-4 AI
                        </button>
                        <div id="api-status" style="margin-top: 5px; font-size: 12px; color: #666;">
                            Enter your OpenAI API key to enable GPT-4 powered AI players
                        </div>
                    </div>
                `;
                controls.appendChild(apiKeyContainer);
            }

            setApiKey() {
                const apiKeyInput = document.getElementById('api-key-input');
                const apiKey = apiKeyInput.value.trim();
                const statusDiv = document.getElementById('api-status');
                
                if (apiKey.startsWith('sk-') && apiKey.length > 20) {
                    this.openaiApiKey = apiKey;
                    this.useLLM = true;
                    statusDiv.textContent = 'âœ… GPT-4 AI enabled! Players will now use advanced LLM reasoning.';
                    statusDiv.style.color = '#28a745';
                    console.log('OpenAI API key configured, LLM mode enabled');
                } else {
                    statusDiv.textContent = 'âŒ Invalid API key format. Please enter a valid OpenAI API key.';
                    statusDiv.style.color = '#dc3545';
                }
            }

            async callOpenAI(prompt, maxTokens = 150) {
                if (!this.openaiApiKey) {
                    throw new Error('OpenAI API key not configured');
                }

                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.openaiApiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4',
                            messages: [
                                {
                                    role: 'system',
                                    content: `You are a world-class Yahtzee master with decades of tournament experience. You understand every nuance of optimal Yahtzee strategy.

KEY STRATEGIC PRINCIPLES:
1. NEVER waste high-value combinations (Yahtzee=50, Large Straight=40, Full House=25, Small Straight=30)
2. Straights are FRAGILE - missing even one number breaks them completely
3. For straights, you need EXACTLY consecutive numbers: 1-2-3-4, 2-3-4-5, 3-4-5-6 (small), or 1-2-3-4-5, 2-3-4-5-6 (large)
4. Upper section bonus requires 63+ points (3+ of each number 1-6)
5. Late in game, sometimes take a zero to preserve high-value categories

PROFESSIONAL STRATEGY (from expert guides):
6. PRIORITIZE 4s, 5s, and 6s in upper section - these are your path to the 63-point bonus
7. AVOID using 1s and 2s for 3/4 of a Kind - they yield lower totals than higher numbers
8. STRATEGICALLY ZERO 1s and 2s boxes to preserve better scoring opportunities
9. ROLL for Yahtzees EARLY in the game for maximum point potential (first=50pts, additional=100pts bonus)
10. SAVE Chance category for late game as a strategic safety net
11. ZERO OUT Yahtzee box near end if probability of rolling another is extremely low

STRAIGHT STRATEGY MASTERY:
- Small Straight (30 pts): Need any 4 consecutive numbers (1-2-3-4, 2-3-4-5, or 3-4-5-6)
- Large Straight (40 pts): Need exactly 5 consecutive numbers (1-2-3-4-5 or 2-3-4-5-6)
- If you have 3 consecutive numbers, calculate probability of getting the 4th
- If you have gaps (like 1-3-4-6), straights are nearly impossible - pivot to other strategies
- Never chase straights with isolated numbers like 1-1-4-6-6

PROBABILITY AWARENESS:
- Chance of rolling specific number in 1 die: 1/6 (16.7%)
- Chance of rolling specific number in 2 dice: 11/36 (30.6%)
- After turn 2, be realistic about what's achievable

CRITICAL: You can ONLY choose categories that are explicitly listed as AVAILABLE. Never choose a category that's already been filled.

Always respond with valid JSON format only.`
                                },
                                {
                                    role: 'user',
                                    content: prompt
                                }
                            ],
                            max_tokens: maxTokens,
                            temperature: 0.3
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`OpenAI API error: ${response.status}`);
                    }

                    const data = await response.json();
                    return data.choices[0].message.content.trim();
                } catch (error) {
                    console.error('OpenAI API call failed:', error);
                    throw error;
                }
            }

            initializeScoreCards() {
                const container = document.getElementById('scorecards-container');
                container.innerHTML = '';
                
                this.players.forEach(player => {
                    const scoreCardHtml = this.createScoreCardHTML(player);
                    container.innerHTML += scoreCardHtml;
                });
            }

            createScoreCardHTML(player) {
                return `
                    <div class="player-scorecard" id="player-${player.id}-scorecard" style="border-left: 4px solid ${player.color}">
                        <div class="player-info">
                            <div class="player-name">${player.name}</div>
                            <div class="player-status" id="player-${player.id}-status">Waiting</div>
                        </div>
                        <table class="scorecard">
                            <thead>
                                <tr>
                                    <th>Category</th>
                                    <th>Score</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="upper-section">
                                    <td colspan="2"><strong>Upper Section</strong></td>
                                </tr>
                                <tr data-category="ones">
                                    <td>Ones</td>
                                    <td class="score-cell" id="player-${player.id}-ones">-</td>
                                </tr>
                                <tr data-category="twos">
                                    <td>Twos</td>
                                    <td class="score-cell" id="player-${player.id}-twos">-</td>
                                </tr>
                                <tr data-category="threes">
                                    <td>Threes</td>
                                    <td class="score-cell" id="player-${player.id}-threes">-</td>
                                </tr>
                                <tr data-category="fours">
                                    <td>Fours</td>
                                    <td class="score-cell" id="player-${player.id}-fours">-</td>
                                </tr>
                                <tr data-category="fives">
                                    <td>Fives</td>
                                    <td class="score-cell" id="player-${player.id}-fives">-</td>
                                </tr>
                                <tr data-category="sixes">
                                    <td>Sixes</td>
                                    <td class="score-cell" id="player-${player.id}-sixes">-</td>
                                </tr>
                                <tr class="subtotal">
                                    <td><strong>Subtotal</strong></td>
                                    <td class="score-cell" id="player-${player.id}-subtotal">0</td>
                                </tr>
                                <tr class="bonus">
                                    <td>Bonus</td>
                                    <td class="score-cell" id="player-${player.id}-bonus">0</td>
                                </tr>
                                <tr class="lower-section">
                                    <td colspan="2"><strong>Lower Section</strong></td>
                                </tr>
                                <tr data-category="three-of-a-kind">
                                    <td>3 of a Kind</td>
                                    <td class="score-cell" id="player-${player.id}-three-of-a-kind">-</td>
                                </tr>
                                <tr data-category="four-of-a-kind">
                                    <td>4 of a Kind</td>
                                    <td class="score-cell" id="player-${player.id}-four-of-a-kind">-</td>
                                </tr>
                                <tr data-category="full-house">
                                    <td>Full House</td>
                                    <td class="score-cell" id="player-${player.id}-full-house">-</td>
                                </tr>
                                <tr data-category="small-straight">
                                    <td>Sm. Straight</td>
                                    <td class="score-cell" id="player-${player.id}-small-straight">-</td>
                                </tr>
                                <tr data-category="large-straight">
                                    <td>Lg. Straight</td>
                                    <td class="score-cell" id="player-${player.id}-large-straight">-</td>
                                </tr>
                                <tr data-category="yahtzee">
                                    <td>Yahtzee</td>
                                    <td class="score-cell" id="player-${player.id}-yahtzee">-</td>
                                </tr>
                                <tr data-category="chance">
                                    <td>Chance</td>
                                    <td class="score-cell" id="player-${player.id}-chance">-</td>
                                </tr>
                                <tr class="total">
                                    <td><strong>Total</strong></td>
                                    <td class="score-cell" id="player-${player.id}-total">0</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                `;
            }

            setDiceFace(element, value) {
                // Simply show the number
                element.textContent = value;
            }

            isYahtzee() {
                const counts = {};
                this.dice.forEach(die => counts[die] = (counts[die] || 0) + 1);
                return Object.values(counts).includes(5);
            }

            forceYahtzee() {
                // Set all dice to the same value for testing
                const value = Math.floor(Math.random() * 6) + 1;
                for (let i = 0; i < 5; i++) {
                    this.dice[i] = value;
                    this.setDiceFace(document.getElementById(`die-${i}`), value);
                }
                
                // Trigger fireworks immediately
                setTimeout(() => {
                    this.showFireworks();
                }, 500);
                
                console.log('Forced Yahtzee with all', value + 's');
            }

            showFireworks() {
                // Create fireworks container
                const fireworksContainer = document.createElement('div');
                fireworksContainer.className = 'fireworks';
                
                // Create many more firework bursts covering the entire screen
                const burstPositions = [
                    {left: 10, top: 20}, {left: 25, top: 30}, {left: 40, top: 15}, 
                    {left: 55, top: 35}, {left: 70, top: 25}, {left: 85, top: 40},
                    {left: 15, top: 60}, {left: 30, top: 70}, {left: 45, top: 55}, 
                    {left: 60, top: 75}, {left: 75, top: 65}, {left: 90, top: 80},
                    {left: 20, top: 90}, {left: 35, top: 10}, {left: 50, top: 95},
                    {left: 65, top: 5}, {left: 80, top: 85}, {left: 5, top: 50}
                ];
                
                burstPositions.forEach((pos, burst) => {
                    setTimeout(() => {
                        const burstContainer = document.createElement('div');
                        burstContainer.style.position = 'absolute';
                        burstContainer.style.left = `${pos.left}%`;
                        burstContainer.style.top = `${pos.top}%`;
                        
                        // Create individual firework particles (20 per burst for more density)
                        for (let i = 0; i < 20; i++) {
                            const firework = document.createElement('div');
                            firework.className = 'firework';
                            burstContainer.appendChild(firework);
                        }
                        
                        fireworksContainer.appendChild(burstContainer);
                    }, burst * 100); // Faster bursts for more action
                });
                
                // Create YAHTZEE message
                const message = document.createElement('div');
                message.className = 'yahtzee-message';
                message.textContent = 'ðŸŽ¯ YAHTZEE! ðŸŽ¯';
                
                document.body.appendChild(fireworksContainer);
                document.body.appendChild(message);
                
                // Clean up after animation
                setTimeout(() => {
                    document.body.removeChild(fireworksContainer);
                    document.body.removeChild(message);
                }, 4000); // Longer duration for the spectacular show
            }

            rollDice() {
                if (!this.gameStarted) {
                    this.gameStarted = true;
                }
                
                // Clear previous suggestions when starting a new roll
                this.suggestedDice = [false, false, false, false, false];
                
                // Disable roll button during animation
                const rollBtn = document.getElementById('roll-btn');
                rollBtn.disabled = true;
                rollBtn.textContent = 'Rolling...';
                
                const animationDurations = [];
                let maxDuration = 0;
                
                // Start rolling animations for non-held dice with random durations
                for (let i = 0; i < 5; i++) {
                    const dieElement = document.getElementById(`die-${i}`);
                    if (!this.heldDice[i]) {
                        // Clear suggested class immediately when starting to roll
                        dieElement.classList.remove('suggested');
                        
                        // Random duration between 1500ms and 3000ms
                        const duration = 1500 + Math.random() * 1500;
                        animationDurations[i] = duration;
                        maxDuration = Math.max(maxDuration, duration);
                        
                        // Set custom animation duration
                        dieElement.style.animationDuration = `${duration}ms`;
                        dieElement.classList.add('rolling');
                        dieElement.textContent = 'ðŸŽ²';
                        
                        // Set individual timeout for each die
                        setTimeout(() => {
                            this.dice[i] = Math.floor(Math.random() * 6) + 1;
                            dieElement.classList.remove('rolling');
                            dieElement.style.animationDuration = ''; // Reset to default
                            this.setDiceFace(dieElement, this.dice[i]);
                        }, duration);
                        
                    } else {
                        dieElement.classList.add('shake');
                        setTimeout(() => {
                            dieElement.classList.remove('shake');
                        }, 500);
                    }
                }
                
                // After all animations complete, update the game state
                setTimeout(() => {
                    this.turn++;
                    this.updateDisplay();
                    
                    // Check for Yahtzee and show fireworks (on any roll)
                    if (this.isYahtzee()) {
                        console.log('YAHTZEE detected on turn', this.turn);
                        setTimeout(() => {
                            this.showFireworks();
                        }, 500);
                    }
                }, maxDuration + 100);
            }

            toggleHold(diceIndex) {
                if (this.gameStarted && this.turn > 0 && this.turn < this.maxTurns) {
                    this.heldDice[diceIndex] = !this.heldDice[diceIndex];
                    this.updateDisplay();
                }
            }

            analyzeDice() {
                const counts = {};
                this.dice.forEach(die => counts[die] = (counts[die] || 0) + 1);
                
                const sortedCounts = Object.entries(counts).sort((a, b) => b[1] - a[1]);
                const maxCount = sortedCounts[0][1];
                const maxValue = parseInt(sortedCounts[0][0]);
                
                // Reset suggestions
                this.suggestedDice = [false, false, false, false, false];
                
                let suggestion = "";
                
                // Check for Yahtzee (5 of a kind)
                if (maxCount === 5) {
                    suggestion = "ðŸŽ‰ YAHTZEE! Keep all dice!";
                    this.suggestedDice = [true, true, true, true, true];
                }
                // Check for 4 of a kind
                else if (maxCount === 4) {
                    suggestion = `Keep all four ${maxValue}s for Four of a Kind!`;
                    for (let i = 0; i < 5; i++) {
                        if (this.dice[i] === maxValue) this.suggestedDice[i] = true;
                    }
                }
                // Check for 3 of a kind
                else if (maxCount === 3) {
                    suggestion = `Keep the three ${maxValue}s for Three of a Kind!`;
                    for (let i = 0; i < 5; i++) {
                        if (this.dice[i] === maxValue) this.suggestedDice[i] = true;
                    }
                }
                // Check for pairs
                else if (maxCount === 2) {
                    const pairs = sortedCounts.filter(([value, count]) => count === 2);
                    if (pairs.length === 2) {
                        suggestion = "Two Pair! Keep both pairs for Full House potential!";
                        pairs.forEach(([value]) => {
                            for (let i = 0; i < 5; i++) {
                                if (this.dice[i] === parseInt(value)) this.suggestedDice[i] = true;
                            }
                        });
                    } else {
                        suggestion = `Keep the pair of ${maxValue}s!`;
                        for (let i = 0; i < 5; i++) {
                            if (this.dice[i] === maxValue) this.suggestedDice[i] = true;
                        }
                    }
                }
                // Check for straights
                else {
                    const uniqueDice = [...new Set(this.dice)].sort((a, b) => a - b);
                    let consecutive = 1;
                    let maxConsecutive = 1;
                    let straightStart = uniqueDice[0];
                    
                    for (let i = 1; i < uniqueDice.length; i++) {
                        if (uniqueDice[i] === uniqueDice[i-1] + 1) {
                            consecutive++;
                            if (consecutive > maxConsecutive) {
                                maxConsecutive = consecutive;
                                straightStart = uniqueDice[i - consecutive + 1];
                            }
                        } else {
                            consecutive = 1;
                        }
                    }
                    
                    if (maxConsecutive >= 4) {
                        suggestion = maxConsecutive === 5 ? "Large Straight! Keep all!" : "Small Straight potential! Keep the sequence!";
                        for (let i = 0; i < 5; i++) {
                            const die = this.dice[i];
                            if (die >= straightStart && die < straightStart + maxConsecutive) {
                                this.suggestedDice[i] = true;
                            }
                        }
                    } else if (maxConsecutive === 3) {
                        suggestion = "Keep the 3-card sequence for straight potential!";
                        for (let i = 0; i < 5; i++) {
                            const die = this.dice[i];
                            if (die >= straightStart && die < straightStart + 3) {
                                this.suggestedDice[i] = true;
                            }
                        }
                    } else {
                        // Keep highest dice for chance
                        const highDice = Math.max(...this.dice);
                        suggestion = `Keep the ${highDice}s for highest score!`;
                        for (let i = 0; i < 5; i++) {
                            if (this.dice[i] === highDice) this.suggestedDice[i] = true;
                        }
                    }
                }
                
                return suggestion;
            }

            calculateYahtzeeScores() {
                const counts = {};
                this.dice.forEach(die => counts[die] = (counts[die] || 0) + 1);
                const sortedCounts = Object.entries(counts).sort((a, b) => b[1] - a[1]);
                const uniqueDice = [...new Set(this.dice)].sort((a, b) => a - b);
                
                const scores = {};
                
                // Upper section (ones through sixes)
                for (let i = 1; i <= 6; i++) {
                    scores[`${i}s`] = (counts[i] || 0) * i;
                }
                
                // Three of a kind
                const maxCount = sortedCounts[0][1];
                if (maxCount >= 3) {
                    scores['Three of a Kind'] = this.dice.reduce((sum, die) => sum + die, 0);
                }
                
                // Four of a kind
                if (maxCount >= 4) {
                    scores['Four of a Kind'] = this.dice.reduce((sum, die) => sum + die, 0);
                }
                
                // Full house
                const hasThree = sortedCounts.some(([_, count]) => count === 3);
                const hasTwo = sortedCounts.some(([_, count]) => count === 2);
                const hasTwoPair = sortedCounts.filter(([_, count]) => count === 2).length === 2;
                if ((hasThree && hasTwo) || (hasThree && hasTwoPair)) {
                    scores['Full House'] = 25;
                }
                
                // Small straight
                const straights = [
                    [1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]
                ];
                for (let straight of straights) {
                    if (straight.every(num => uniqueDice.includes(num))) {
                        scores['Small Straight'] = 30;
                        break;
                    }
                }
                
                // Large straight
                const largeStraights = [
                    [1, 2, 3, 4, 5], [2, 3, 4, 5, 6]
                ];
                for (let straight of largeStraights) {
                    if (straight.every(num => uniqueDice.includes(num)) && uniqueDice.length === 5) {
                        scores['Large Straight'] = 40;
                        break;
                    }
                }
                
                // Yahtzee
                if (maxCount === 5) {
                    scores['Yahtzee'] = 50;
                }
                
                // Chance
                scores['Chance'] = this.dice.reduce((sum, die) => sum + die, 0);
                
                return scores;
            }

            getBestScore() {
                const scores = this.calculateYahtzeeScores();
                const validScores = Object.entries(scores).filter(([_, score]) => score > 0);
                
                if (validScores.length === 0) {
                    return { category: 'Chance', score: scores['Chance'] };
                }
                
                const bestScore = validScores.reduce((best, current) => 
                    current[1] > best[1] ? current : best
                );
                
                return { category: bestScore[0], score: bestScore[1] };
            }

            scoreCategory(category, dice = this.dice) {
                const counts = {};
                dice.forEach(die => counts[die] = (counts[die] || 0) + 1);
                const sortedCounts = Object.entries(counts).sort((a, b) => b[1] - a[1]);
                const maxCount = sortedCounts[0][1];
                const uniqueDice = [...new Set(dice)].sort((a, b) => a - b);
                
                switch(category) {
                    case 'ones': return (counts[1] || 0) * 1;
                    case 'twos': return (counts[2] || 0) * 2;
                    case 'threes': return (counts[3] || 0) * 3;
                    case 'fours': return (counts[4] || 0) * 4;
                    case 'fives': return (counts[5] || 0) * 5;
                    case 'sixes': return (counts[6] || 0) * 6;
                    case 'three-of-a-kind': 
                        return maxCount >= 3 ? dice.reduce((sum, die) => sum + die, 0) : 0;
                    case 'four-of-a-kind': 
                        return maxCount >= 4 ? dice.reduce((sum, die) => sum + die, 0) : 0;
                    case 'full-house': 
                        const hasThree = sortedCounts.some(([_, count]) => count === 3);
                        const hasTwo = sortedCounts.some(([_, count]) => count === 2);
                        return (hasThree && hasTwo) ? 25 : 0;
                    case 'small-straight': 
                        const smallStraights = [[1,2,3,4], [2,3,4,5], [3,4,5,6]];
                        return smallStraights.some(straight => 
                            straight.every(num => uniqueDice.includes(num))) ? 30 : 0;
                    case 'large-straight': 
                        const largeStraights = [[1,2,3,4,5], [2,3,4,5,6]];
                        return largeStraights.some(straight => 
                            straight.every(num => uniqueDice.includes(num)) && uniqueDice.length === 5) ? 40 : 0;
                    case 'yahtzee': 
                        return maxCount === 5 ? 50 : 0;
                    case 'chance': 
                        return dice.reduce((sum, die) => sum + die, 0);
                    default: return 0;
                }
            }

            updateScorecard(player) {
                const upperCategories = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'];
                let upperTotal = 0;
                
                upperCategories.forEach(category => {
                    if (player.scorecard[category] !== undefined) {
                        upperTotal += player.scorecard[category];
                    }
                });
                
                document.getElementById(`player-${player.id}-subtotal`).textContent = upperTotal;
                
                // Upper section bonus
                const bonus = upperTotal >= 63 ? 35 : 0;
                document.getElementById(`player-${player.id}-bonus`).textContent = bonus;
                
                // Calculate total score
                let totalScore = upperTotal + bonus;
                const lowerCategories = ['three-of-a-kind', 'four-of-a-kind', 'full-house', 
                                       'small-straight', 'large-straight', 'yahtzee', 'chance'];
                
                lowerCategories.forEach(category => {
                    if (player.scorecard[category] !== undefined) {
                        totalScore += player.scorecard[category];
                    }
                });
                
                document.getElementById(`player-${player.id}-total`).textContent = totalScore;
            }

            fillScorecard(player, category, score) {
                player.scorecard[category] = score;
                document.getElementById(`player-${player.id}-${category}`).textContent = score;
                this.updateScorecard(player);
            }

            getAvailableCategories(player) {
                const allCategories = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes',
                                     'three-of-a-kind', 'four-of-a-kind', 'full-house',
                                     'small-straight', 'large-straight', 'yahtzee', 'chance'];
                return allCategories.filter(cat => player.scorecard[cat] === undefined);
            }

            getCurrentPlayer() {
                return this.players[this.currentPlayerIndex];
            }

            setActivePlayer(player) {
                // Remove active class from all players
                this.players.forEach(p => {
                    document.getElementById(`player-${p.id}-scorecard`).classList.remove('active-player');
                    document.getElementById(`player-${p.id}-status`).textContent = 'Waiting';
                    document.getElementById(`player-${p.id}-status`).classList.remove('playing');
                });
                
                // Set active player
                document.getElementById(`player-${player.id}-scorecard`).classList.add('active-player');
                document.getElementById(`player-${player.id}-status`).textContent = 'Playing';
                document.getElementById(`player-${player.id}-status`).classList.add('playing');
            }

            // AI Auto-play functions with scorecard-aware strategy
            autoPlayDecideHold(player) {
                const availableCategories = this.getAvailableCategories(player);
                const newHeldDice = [false, false, false, false, false];
                const counts = {};
                this.dice.forEach(die => counts[die] = (counts[die] || 0) + 1);
                
                console.log(`${player.name} deciding what to hold. Available categories: ${availableCategories.join(', ')}`);
                console.log(`Current dice: [${this.dice.join(', ')}]`);
                
                // Apply different AI strategies based on player personality
                return this.applyPlayerStrategy(player, availableCategories, counts);
            }

            applyPlayerStrategy(player, availableCategories, counts) {
                switch(player.strategy) {
                    case 'aggressive':
                        return this.aggressiveStrategy(player, availableCategories, counts);
                    case 'conservative': 
                        return this.conservativeStrategy(player, availableCategories, counts);
                    case 'random':
                        return this.randomStrategy(counts);
                    case 'strategic':
                    default:
                        return this.strategicStrategy(player, availableCategories, counts);
                }
            }

            strategicStrategy(player, availableCategories, counts) {
                // Original smart strategy
                const strategy = this.analyzeScoreCardNeeds(availableCategories, player);
                
                // Check for high-value completable categories first
                let bestCurrentScore = -1;
                let bestCurrentCategory = null;
                
                availableCategories.forEach(category => {
                    const score = this.scoreCategory(category);
                    if (score > bestCurrentScore) {
                        bestCurrentScore = score;
                        bestCurrentCategory = category;
                    }
                });
                
                if (bestCurrentScore >= 40 || 
                    (bestCurrentCategory === 'full-house' && bestCurrentScore === 25) ||
                    (bestCurrentCategory === 'small-straight' && bestCurrentScore === 30)) {
                    console.log(`${player.name} keeps all dice for ${bestCurrentCategory} (${bestCurrentScore} points)`);
                    return [true, true, true, true, true];
                }
                
                if (strategy.needUpperSection) {
                    return this.holdForUpperSection(strategy.priorityNumbers, counts);
                }
                if (strategy.needYahtzee) {
                    return this.holdForYahtzee(counts);
                }
                if (strategy.needStraights) {
                    return this.holdForStraights();
                }
                if (strategy.needFullHouse) {
                    return this.holdForFullHouse(counts);
                }
                if (strategy.needMultiples) {
                    return this.holdForMultiples(counts);
                }
                
                return this.holdBasicStrategy(counts);
            }

            aggressiveStrategy(player, availableCategories, counts) {
                console.log(`${player.name} using aggressive strategy - going for high-value categories!`);
                
                // Always go for Yahtzee if possible
                if (availableCategories.includes('yahtzee')) {
                    return this.holdForYahtzee(counts);
                }
                
                // Prefer straights and full house over safe choices
                if (availableCategories.includes('large-straight') || availableCategories.includes('small-straight')) {
                    return this.holdForStraights();
                }
                
                if (availableCategories.includes('full-house')) {
                    return this.holdForFullHouse(counts);
                }
                
                // Otherwise hold for multiples
                return this.holdForMultiples(counts);
            }

            conservativeStrategy(player, availableCategories, counts) {
                console.log(`${player.name} using conservative strategy - playing it safe!`);
                
                // Always take guaranteed scores
                const guaranteedScores = availableCategories.filter(cat => this.scoreCategory(cat) > 0);
                if (guaranteedScores.length > 0) {
                    // Hold everything if we have a decent score
                    const bestScore = Math.max(...guaranteedScores.map(cat => this.scoreCategory(cat)));
                    if (bestScore >= 15) {
                        return [true, true, true, true, true];
                    }
                }
                
                // Focus on upper section for bonus
                const strategy = this.analyzeScoreCardNeeds(availableCategories, player);
                if (strategy.needUpperSection) {
                    return this.holdForUpperSection(strategy.priorityNumbers, counts);
                }
                
                // Hold pairs and multiples (safe choices)
                return this.holdBasicStrategy(counts);
            }

            randomStrategy(counts) {
                console.log('Wild Wendy using random strategy - anything can happen!');
                
                const newHeldDice = [false, false, false, false, false];
                
                // Randomly decide for each die (30% chance to hold each)
                for (let i = 0; i < 5; i++) {
                    newHeldDice[i] = Math.random() < 0.3;
                }
                
                return newHeldDice;
            }

            analyzeScoreCardNeeds(availableCategories, player) {
                const upperCategories = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'];
                const availableUpper = availableCategories.filter(cat => upperCategories.includes(cat));
                
                // Calculate current upper section total for the specific player
                let currentUpperTotal = 0;
                upperCategories.forEach(cat => {
                    if (player.scorecard[cat] !== undefined) {
                        currentUpperTotal += player.scorecard[cat];
                    }
                });
                
                const needsUpperBonus = currentUpperTotal < 63 && availableUpper.length > 0;
                
                return {
                    needUpperSection: needsUpperBonus,
                    priorityNumbers: needsUpperBonus ? [4, 5, 6] : [1, 2, 3], // Focus on high numbers for bonus
                    needYahtzee: availableCategories.includes('yahtzee'),
                    needStraights: availableCategories.includes('small-straight') || availableCategories.includes('large-straight'),
                    needFullHouse: availableCategories.includes('full-house'),
                    needMultiples: availableCategories.includes('three-of-a-kind') || availableCategories.includes('four-of-a-kind'),
                    upperSectionProgress: currentUpperTotal,
                    remainingUpperCategories: availableUpper
                };
            }

            holdForUpperSection(priorityNumbers, counts) {
                const newHeldDice = [false, false, false, false, false];
                
                // Prioritize keeping high-value numbers (4, 5, 6) for upper section bonus
                priorityNumbers.forEach(num => {
                    if (counts[num] >= 1) {
                        this.dice.forEach((die, index) => {
                            if (die === num) {
                                newHeldDice[index] = true;
                            }
                        });
                    }
                });
                
                console.log(`AI holding for upper section, prioritizing: ${priorityNumbers.join(', ')}`);
                return newHeldDice;
            }

            holdForYahtzee(counts) {
                const newHeldDice = [false, false, false, false, false];
                
                // Find the number with the most occurrences
                let maxCount = 0;
                let maxValue = 0;
                
                Object.entries(counts).forEach(([value, count]) => {
                    if (count > maxCount) {
                        maxCount = count;
                        maxValue = parseInt(value);
                    }
                });
                
                // Hold all dice of the most frequent value
                if (maxCount >= 2) {
                    this.dice.forEach((die, index) => {
                        if (die === maxValue) {
                            newHeldDice[index] = true;
                        }
                    });
                    console.log(`AI holding ${maxCount} ${maxValue}s for Yahtzee potential`);
                }
                
                return newHeldDice;
            }

            holdForStraights() {
                const newHeldDice = [false, false, false, false, false];
                const uniqueDice = [...new Set(this.dice)].sort((a, b) => a - b);
                
                // Look for consecutive sequences
                let longestSequence = [];
                let currentSequence = [uniqueDice[0]];
                
                for (let i = 1; i < uniqueDice.length; i++) {
                    if (uniqueDice[i] === uniqueDice[i-1] + 1) {
                        currentSequence.push(uniqueDice[i]);
                    } else {
                        if (currentSequence.length > longestSequence.length) {
                            longestSequence = [...currentSequence];
                        }
                        currentSequence = [uniqueDice[i]];
                    }
                }
                
                if (currentSequence.length > longestSequence.length) {
                    longestSequence = [...currentSequence];
                }
                
                // Hold dice that are part of the longest sequence
                if (longestSequence.length >= 3) {
                    this.dice.forEach((die, index) => {
                        if (longestSequence.includes(die)) {
                            newHeldDice[index] = true;
                        }
                    });
                    console.log(`AI holding straight sequence: ${longestSequence.join(', ')}`);
                }
                
                return newHeldDice;
            }

            holdForFullHouse(counts) {
                const newHeldDice = [false, false, false, false, false];
                
                let threeOfAKind = null;
                let pair = null;
                
                Object.entries(counts).forEach(([value, count]) => {
                    if (count >= 3 && !threeOfAKind) {
                        threeOfAKind = parseInt(value);
                    } else if (count >= 2 && !pair) {
                        pair = parseInt(value);
                    }
                });
                
                // Hold three of a kind and pairs for full house
                if (threeOfAKind) {
                    this.dice.forEach((die, index) => {
                        if (die === threeOfAKind) {
                            newHeldDice[index] = true;
                        }
                    });
                }
                
                if (pair && pair !== threeOfAKind) {
                    this.dice.forEach((die, index) => {
                        if (die === pair && !newHeldDice[index]) {
                            newHeldDice[index] = true;
                        }
                    });
                }
                
                console.log(`AI holding for Full House: ${threeOfAKind ? threeOfAKind + 's' : 'none'} and ${pair ? pair + 's' : 'none'}`);
                return newHeldDice;
            }

            holdForMultiples(counts) {
                const newHeldDice = [false, false, false, false, false];
                
                // Hold any multiples (pairs, three-of-a-kind, etc.)
                Object.entries(counts).forEach(([value, count]) => {
                    if (count >= 2) {
                        this.dice.forEach((die, index) => {
                            if (die == value) {
                                newHeldDice[index] = true;
                            }
                        });
                    }
                });
                
                console.log(`AI holding multiples for Three/Four of a Kind`);
                return newHeldDice;
            }

            holdBasicStrategy(counts) {
                const newHeldDice = [false, false, false, false, false];
                
                // Hold pairs first
                Object.entries(counts).forEach(([value, count]) => {
                    if (count >= 2) {
                        this.dice.forEach((die, index) => {
                            if (die == value) {
                                newHeldDice[index] = true;
                            }
                        });
                    }
                });
                
                // If no pairs, hold high dice (5s and 6s)
                if (!newHeldDice.some(held => held)) {
                    this.dice.forEach((die, index) => {
                        if (die >= 5) {
                            newHeldDice[index] = true;
                        }
                    });
                    console.log(`AI holding high dice (5s and 6s)`);
                } else {
                    console.log(`AI holding pairs/multiples`);
                }
                
                return newHeldDice;
            }

            async llmDecideHold(player) {
                if (!this.useLLM) {
                    return this.autoPlayDecideHold(player); // Fallback to traditional AI
                }

                try {
                    const availableCategories = this.getAvailableCategories(player);
                    const currentScores = this.formatScorecard(player);
                    
                    const diceAnalysis = this.analyzeDiceForLLM();
                    const prompt = `You are ${player.name}, an AI Yahtzee player with ${player.strategy} strategy.

CURRENT DICE: [${this.dice.join(', ')}]
DICE POSITIONS: [Position 1: ${this.dice[0]}, Position 2: ${this.dice[1]}, Position 3: ${this.dice[2]}, Position 4: ${this.dice[3]}, Position 5: ${this.dice[4]}]
TURN: ${this.turn}/3
PLAYER PERSONALITY: ${this.getPlayerPersonality(player)}

DICE ANALYSIS:
${diceAnalysis}

CURRENT SCORECARD STATUS:
${currentScores}

AVAILABLE CATEGORIES: ${availableCategories.join(', ')}

Based on the dice roll, your current scorecard, and your personality, decide which dice to hold for the next roll.

DETAILED STRATEGIC ANALYSIS:

STRAIGHT STRATEGY (Most Important):
- Small Straight Examples: If you have [1,2,3,6,6], hold 1-2-3 and try for 4 or 5
- Large Straight Examples: If you have [2,3,4,5,1], hold all five - you have large straight!
- BAD Straight Attempts: Never chase straights with gaps like [1,1,3,5,6] - pivot to pairs instead
- Turn 1: Chase straights if you have 3+ consecutive numbers
- Turn 2: Only chase straights if you have 4 consecutive (small) or very close to large straight
- Turn 3: Don't chase straights unless you're 1 number away

MULTIPLES STRATEGY:
- 4+ of a kind: ALWAYS hold all matching dice (Yahtzee=50 pts vs Four of a Kind)
- 3 of a kind: Hold all three, try for fourth
- Pairs: Good for Full House, but abandon if better options exist
- Multiple pairs: Excellent for Full House potential

UPPER SECTION STRATEGY (Expert Level):
- Need 63+ total for 35 bonus points (average 10.5 per category)
- PRIORITY ORDER: 6s > 5s > 4s > 3s > 2s > 1s (focus on high numbers!)
- EXPERT TIP: If you roll high numbers of 4s, 5s, or 6s, ALWAYS use them in upper section first
- STRATEGIC ZEROS: Consider zeroing 1s and 2s to preserve better opportunities
- Don't chase upper section if you already have 63+ points
- AVOID using 1s/2s for Three/Four of a Kind - use higher numbers instead

TURN-SPECIFIC STRATEGY:
- Turn 1: Be aggressive, chase high-value combinations
- Turn 2: Be more selective, focus on achievable goals
- Turn 3: Be realistic, don't chase impossible combinations

SPECIFIC EXAMPLES:
- [1,2,3,4,6]: Hold 1-2-3-4 (small straight guaranteed!) 
- [2,3,4,5,5]: Hold 2-3-4-5 (small straight + chance for large)
- [1,3,4,5,6]: Hold 3-4-5 only if desperate for straights, otherwise hold 5-6 for chance
- [4,4,4,2,6]: Hold all three 4s (go for four of a kind or keep for three of a kind)
- [1,1,5,6,6]: Hold 5-6-6 or 1-1 depending on scorecard needs

CRITICAL: Always consider what categories you still need vs. what's realistically achievable with remaining rolls.

Respond with ONLY a JSON object in this exact format:
{
  "hold": [true, false, true, false, false],
  "reasoning": "Brief explanation of why you're holding these dice"
}

CRITICAL INSTRUCTIONS FOR THE "hold" ARRAY:
- The array must have exactly 5 boolean values (true/false)
- Position 1 (index 0) = true means hold the first die, false means reroll it
- Position 2 (index 1) = true means hold the second die, false means reroll it
- And so on for all 5 positions

EXAMPLE: If dice are [1,3,3,1,5] and you want to hold both 1s and both 3s:
- Position 1: die=1, hold=true
- Position 2: die=3, hold=true  
- Position 3: die=3, hold=true
- Position 4: die=1, hold=true
- Position 5: die=5, hold=false
- Answer: {"hold": [true, true, true, true, false], "reasoning": "Holding both pairs (1s and 3s)"}

ANOTHER EXAMPLE: If dice are [1,2,3,4,5] and you want to hold 1-2-3 consecutive:
- Position 1: die=1, hold=true (holding the 1)
- Position 2: die=2, hold=true (holding the 2)
- Position 3: die=3, hold=true (holding the 3)
- Position 4: die=4, hold=false (not holding the 4)
- Position 5: die=5, hold=false (not holding the 5)
- Answer: {"hold": [true, true, true, false, false], "reasoning": "Holding consecutive numbers 1-2-3"}

âš ï¸ CRITICAL: Your hold array MUST match exactly what you say in your reasoning!`;

                    console.log(`${player.name} Dice for analysis: [${this.dice.join(', ')}]`);
                    console.log(`${player.name} Dice positions: ${this.dice.map((die, i) => `pos${i+1}=${die}`).join(', ')}`);

                    const response = await this.callOpenAI(prompt, 200);
                    console.log(`${player.name} LLM response:`, response);
                    
                    const decision = JSON.parse(response);
                    console.log(`${player.name} LLM decision: ${decision.reasoning}`);
                    console.log(`${player.name} LLM wants to hold:`, decision.hold);
                    console.log(`${player.name} Current dice:`, this.dice);
                    
                    // Validate the hold array
                    if (!Array.isArray(decision.hold) || decision.hold.length !== 5) {
                        console.error(`ðŸš« Invalid hold array from ${player.name}:`, decision.hold);
                        return this.autoPlayDecideHold(player); // Fallback
                    }
                    
                    // Show what will actually be held
                    const heldDice = this.dice.filter((die, index) => decision.hold[index]);
                    const notHeldDice = this.dice.filter((die, index) => !decision.hold[index]);
                    console.log(`${player.name} Will hold: [${heldDice.join(', ')}]`);
                    console.log(`${player.name} Will reroll: [${notHeldDice.join(', ')}]`);
                    
                    // Validate reasoning consistency
                    const inconsistency = this.validateHoldConsistency(decision.reasoning, decision.hold, this.dice);
                    if (inconsistency) {
                        console.warn(`ðŸš¨ ${player.name} INCONSISTENCY: ${inconsistency}`);
                    }
                    
                    // Show reasoning in UI with actual dice being held
                    let enhancedReasoning = `${decision.reasoning}\n\nðŸŽ² Actually holding: [${heldDice.join(', ')}]\nðŸ”„ Will reroll: [${notHeldDice.join(', ')}]`;
                    if (inconsistency) {
                        enhancedReasoning += `\n\nâš ï¸ INCONSISTENCY DETECTED: ${inconsistency}`;
                    }
                    this.showAIReasoning(player, `ðŸŽ² Dice Hold Decision (Turn ${this.turn})`, enhancedReasoning);
                    
                    return decision.hold;
                } catch (error) {
                    console.error(`LLM decision failed for ${player.name}, using fallback:`, error);
                    return this.autoPlayDecideHold(player); // Fallback to traditional AI
                }
            }

            async llmChooseCategory(player) {
                if (!this.useLLM) {
                    return this.autoPlayChooseCategory(player); // Fallback to traditional AI
                }

                try {
                    const availableCategories = this.getAvailableCategories(player);
                    const currentScores = this.formatScorecard(player);
                    const possibleScores = {};
                    
                    availableCategories.forEach(category => {
                        possibleScores[category] = this.scoreCategory(category);
                    });

                    const diceAnalysis = this.analyzeDiceForLLM();
                    const prompt = `You are ${player.name}, an AI Yahtzee player with ${player.strategy} strategy.

ðŸŽ¯ AVAILABLE CATEGORIES (ONLY THESE CAN BE CHOSEN):
${Object.entries(possibleScores).map(([cat, score]) => `âœ… ${cat}: ${score} points`).join('\n')}

FINAL DICE: [${this.dice.join(', ')}]
PLAYER PERSONALITY: ${this.getPlayerPersonality(player)}

DICE ANALYSIS:
${diceAnalysis}

CURRENT SCORECARD STATUS:
${currentScores}

Based on your final dice roll, current scorecard, and personality, choose which category to score.

CRITICAL STRATEGIC RULES:
1. NEVER use Yahtzee (5 of a kind) for anything other than the "yahtzee" category (50 points)
2. NEVER use Four of a Kind for "three-of-a-kind" when "four-of-a-kind" is available
3. NEVER use Full House for "three-of-a-kind" when "full-house" is available (25 points)
4. NEVER use Large Straight for "small-straight" when "large-straight" is available (40 points)
5. Always prioritize the highest-scoring category that matches your dice
6. Consider upper section bonus (need 63+ points in upper section for 35 bonus points)

ADVANCED STRATEGIC DECISION MAKING:

STRAIGHT RECOGNITION:
- Small Straight: 1-2-3-4, 2-3-4-5, or 3-4-5-6 (can have extra dice)
- Large Straight: EXACTLY 1-2-3-4-5 or 2-3-4-5-6 (no duplicates)
- Example: [1,2,3,4,4] = Small Straight (30 pts), NOT Large Straight
- Example: [2,3,4,5,6] = Large Straight (40 pts)

UPPER SECTION BONUS MATH:
- Need 63+ points across ones through sixes for 35 bonus
- That's 10.5 average per category (3+ of each number)
- Late game: If you have 45+ upper section points, prioritize filling upper section
- If you have < 30 upper section points with few categories left, bonus is unlikely

GAME SITUATION ANALYSIS (Expert Timing):
- Early game (rounds 1-4): AGGRESSIVELY pursue Yahtzees (50 pts + potential 100 pt bonuses), Large Straights, Full Houses
- Mid game (rounds 5-9): Balance high-value categories with upper section 4s/5s/6s priority
- Late game (rounds 10-13): Use Chance as safety net, consider strategic zeros for 1s/2s
- END GAME: Zero out Yahtzee box if probability is extremely low (save other categories)

SPECIFIC DECISION EXAMPLES (Expert Level):
- If dice = [4,4,4,4,4]: ALWAYS choose "yahtzee" (50 pts) not "fours" (20 pts)
- If dice = [1,2,3,4,5]: ALWAYS choose "large-straight" (40 pts) not "small-straight" (30 pts)
- If dice = [3,3,3,6,6]: Choose "full-house" (25 pts) over "three-of-a-kind" (21 pts)
- If dice = [6,6,6,2,4]: Choose "three-of-a-kind" (22 pts) over "sixes" (18 pts) - higher total!
- If dice = [1,1,1,3,5]: AVOID "three-of-a-kind" (11 pts) - prefer "ones" (3 pts) or zero elsewhere
- If dice = [2,2,4,5,6]: Prioritize "chance" (19 pts) over "twos" (4 pts) unless desperately need upper section
- EXPERT RULE: Never use 1s/2s for multiples unless absolutely necessary - they yield terrible totals

ZERO STRATEGY:
- Sometimes taking a zero in a low-value category preserves high-value categories
- Better to zero "ones" than waste a full house on "three-of-a-kind"
- Never zero high-value categories unless absolutely necessary

EXPERT SCORING HIERARCHY (strategic priority order):
1. Yahtzee (50 pts + 100 pt bonuses) - ABSOLUTE PRIORITY, pursue early!
2. Large Straight (40 pts) - Second highest fixed value
3. Small Straight (30 pts) - Third highest fixed value  
4. Full House (25 pts) - Fourth highest fixed value
5. Four/Three of a Kind with HIGH numbers (4s/5s/6s) - Can yield 20-30 pts
6. Upper Section 4s/5s/6s (if needed for 63+ bonus) - Path to 35 bonus points
7. Four/Three of a Kind with MID numbers (3s) - Moderate value 15-21 pts
8. Chance (sum of all dice) - SAVE for late game as safety net
9. Upper Section 1s/2s/3s - Lower priority unless bonus is achievable
10. AVOID: Three/Four of a Kind with 1s/2s - terrible point efficiency
11. STRATEGIC ZEROS: Zero 1s/2s to preserve better scoring opportunities

Respond with ONLY a JSON object in this exact format:
{
  "category": "chosen-category",
  "reasoning": "Brief explanation of why you chose this category"
}

âš ï¸ CRITICAL CONSTRAINT: The category must be exactly one of these AVAILABLE categories: ${availableCategories.join(', ')}

ðŸš« DO NOT choose any category not in the above list - those are already filled!`;

                    console.log(`${player.name} Available Categories:`, availableCategories);
                    console.log(`${player.name} Possible Scores:`, possibleScores);
                    
                    const response = await this.callOpenAI(prompt, 200);
                    console.log(`${player.name} LLM category response:`, response);
                    
                    const decision = JSON.parse(response);
                    console.log(`${player.name} LLM category choice: ${decision.reasoning}`);
                    
                    // First validate that the category is actually available
                    if (!availableCategories.includes(decision.category)) {
                        console.error(`ðŸš« ${player.name} chose invalid category '${decision.category}' - not in available list: [${availableCategories.join(', ')}]`);
                        console.error(`ðŸš« Player scorecard:`, player.scorecard);
                        decision.category = availableCategories[0]; // Force to first available
                        decision.reasoning += ` [ERROR: AI chose unavailable category, forced to ${decision.category}]`;
                    }
                    
                    // Then validate for strategic mistakes
                    const validatedCategory = this.validateCategoryChoice(decision.category, possibleScores, availableCategories);
                    
                    let finalReasoning = decision.reasoning;
                    if (validatedCategory !== decision.category) {
                        console.log(`âš ï¸ ${player.name} choice corrected from ${decision.category} to ${validatedCategory} to prevent strategic error`);
                        finalReasoning += ` [CORRECTED: System changed choice from ${decision.category} to ${validatedCategory} to prevent strategic error]`;
                    }
                    
                    // Show reasoning in UI
                    this.showAIReasoning(player, `ðŸŽ¯ Category Selection: ${validatedCategory} (${possibleScores[validatedCategory]} pts)`, finalReasoning);
                    
                    return {
                        category: validatedCategory,
                        score: possibleScores[validatedCategory]
                    };
                } catch (error) {
                    console.error(`LLM category choice failed for ${player.name}, using fallback:`, error);
                    return this.autoPlayChooseCategory(player); // Fallback to traditional AI
                }
            }

            getPlayerPersonality(player) {
                const personalities = {
                    'llm-strategic': 'You are highly analytical and make optimal strategic decisions. You carefully consider long-term scoring potential and upper section bonus.',
                    'llm-aggressive': 'You are a risk-taker who goes for high-value categories like Yahtzee, straights, and full house. You prefer big scores over safe plays.',
                    'llm-conservative': 'You prefer guaranteed points and safe plays. You avoid risky moves and focus on consistent scoring, especially in the upper section.',
                    'random': 'You make random decisions without much strategy.'
                };
                return personalities[player.strategy] || 'You play with balanced strategy.';
            }

            analyzeDiceForLLM() {
                const sorted = [...this.dice].sort((a, b) => a - b);
                const counts = {};
                this.dice.forEach(die => counts[die] = (counts[die] || 0) + 1);
                
                let analysis = `Sorted dice: [${sorted.join(', ')}]\n`;
                
                // Count analysis
                const pairs = Object.entries(counts).filter(([_, count]) => count === 2);
                const threes = Object.entries(counts).filter(([_, count]) => count === 3);
                const fours = Object.entries(counts).filter(([_, count]) => count >= 4);
                const fives = Object.entries(counts).filter(([_, count]) => count === 5);
                
                if (fives.length > 0) {
                    analysis += `ðŸŽ¯ YAHTZEE! Five ${fives[0][0]}s - 50 points guaranteed!\n`;
                } else if (fours.length > 0) {
                    analysis += `ðŸŽ² Four of a Kind: Four ${fours[0][0]}s (potential Yahtzee!)\n`;
                } else if (threes.length > 0) {
                    analysis += `ðŸŽ¯ Three of a Kind: Three ${threes[0][0]}s\n`;
                } else if (pairs.length === 2) {
                    analysis += `ðŸŽ² Two Pairs: ${pairs.map(p => p[0]).join(' and ')} (Full House potential!)\n`;
                } else if (pairs.length === 1) {
                    analysis += `ðŸŽ¯ One Pair: ${pairs[0][0]}s\n`;
                }
                
                // Straight analysis
                const unique = [...new Set(this.dice)].sort((a, b) => a - b);
                let consecutiveCount = 1;
                let maxConsecutive = 1;
                let consecutiveStart = unique[0];
                
                for (let i = 1; i < unique.length; i++) {
                    if (unique[i] === unique[i-1] + 1) {
                        consecutiveCount++;
                        if (consecutiveCount > maxConsecutive) {
                            maxConsecutive = consecutiveCount;
                            consecutiveStart = unique[i - consecutiveCount + 1];
                        }
                    } else {
                        consecutiveCount = 1;
                    }
                }
                
                if (maxConsecutive >= 5) {
                    analysis += `ðŸŒŸ LARGE STRAIGHT! [${consecutiveStart}-${consecutiveStart+4}] - 40 points!\n`;
                } else if (maxConsecutive >= 4) {
                    analysis += `âœ¨ SMALL STRAIGHT! [${consecutiveStart}-${consecutiveStart+3}] - 30 points!\n`;
                } else if (maxConsecutive === 3) {
                    analysis += `ðŸ“ˆ Three consecutive numbers [${consecutiveStart}-${consecutiveStart+2}] - chase straight?\n`;
                } else {
                    analysis += `âŒ No straight potential - gaps in sequence\n`;
                }
                
                // Full house analysis
                if (threes.length === 1 && pairs.length === 1) {
                    analysis += `ðŸ  FULL HOUSE! ${threes[0][0]}s and ${pairs[0][0]}s - 25 points!\n`;
                }
                
                return analysis;
            }

            validateHoldConsistency(reasoning, holdArray, dice) {
                const heldDice = dice.filter((die, index) => holdArray[index]);
                const heldSet = new Set(heldDice);
                const heldCounts = {};
                heldDice.forEach(die => heldCounts[die] = (heldCounts[die] || 0) + 1);
                
                const reasoningLower = reasoning.toLowerCase();
                
                // Check for specific claims in reasoning
                if (reasoningLower.includes('consecutive') || reasoningLower.includes('straight')) {
                    // Check if held dice are actually consecutive
                    const sortedHeld = [...heldSet].sort((a, b) => a - b);
                    let isConsecutive = true;
                    for (let i = 1; i < sortedHeld.length; i++) {
                        if (sortedHeld[i] !== sortedHeld[i-1] + 1) {
                            isConsecutive = false;
                            break;
                        }
                    }
                    if (!isConsecutive && sortedHeld.length > 1) {
                        return `Claims consecutive numbers but holding [${heldDice.join(', ')}] which are not consecutive`;
                    }
                }
                
                // Check for specific numbers mentioned
                for (let i = 1; i <= 6; i++) {
                    const numStr = i.toString();
                    if (reasoningLower.includes(`${numStr}s`) || reasoningLower.includes(`${numStr}-`)) {
                        const diceHasNumber = dice.includes(i);
                        const holdingNumber = heldDice.includes(i);
                        const countInDice = dice.filter(d => d === i).length;
                        const countHeld = heldDice.filter(d => d === i).length;
                        
                        if (diceHasNumber && !holdingNumber) {
                            return `Claims to hold ${numStr}s but not actually holding any ${numStr}s`;
                        }
                        
                        if (reasoningLower.includes(`both ${numStr}s`) && countInDice === 2 && countHeld !== 2) {
                            return `Claims to hold both ${numStr}s but only holding ${countHeld} of ${countInDice}`;
                        }
                    }
                }
                
                // Check for pair claims
                if (reasoningLower.includes('pair') || reasoningLower.includes('two ')) {
                    const pairs = Object.entries(heldCounts).filter(([_, count]) => count === 2);
                    if (reasoningLower.includes('both pairs') || reasoningLower.includes('two pairs')) {
                        const allPairs = Object.entries(dice.reduce((acc, die) => {
                            acc[die] = (acc[die] || 0) + 1;
                            return acc;
                        }, {})).filter(([_, count]) => count === 2);
                        
                        if (allPairs.length === 2 && pairs.length !== 2) {
                            return `Claims to hold both pairs but only holding ${pairs.length} pairs`;
                        }
                    }
                }
                
                return null; // No inconsistency found
            }

            formatScorecard(player) {
                const allCategories = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes',
                                     'three-of-a-kind', 'four-of-a-kind', 'full-house',
                                     'small-straight', 'large-straight', 'yahtzee', 'chance'];
                
                const filled = [];
                const empty = [];
                let upperTotal = 0;
                
                allCategories.forEach(category => {
                    if (player.scorecard[category] !== undefined) {
                        filled.push(`${category}: ${player.scorecard[category]}`);
                        if (['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'].includes(category)) {
                            upperTotal += player.scorecard[category];
                        }
                    } else {
                        empty.push(category);
                    }
                });
                
                const result = `SCORECARD STATUS:
================

FILLED CATEGORIES (CANNOT BE USED AGAIN):
${filled.length > 0 ? filled.join('\n') : 'None yet'}

AVAILABLE CATEGORIES (CAN BE USED):
${empty.length > 0 ? empty.join(', ') : 'None remaining'}

UPPER SECTION PROGRESS: ${upperTotal}/63 (need 63 for 35 bonus points)
CATEGORIES REMAINING: ${empty.length}/13

âš ï¸ IMPORTANT: You can ONLY choose from the AVAILABLE CATEGORIES listed above!`;
                
                return result;
            }

            showAIReasoning(player, action, reasoning) {
                console.log(`ðŸ§  showAIReasoning called for ${player.name}: ${action}`);
                const reasoningArea = document.getElementById('ai-reasoning');
                const reasoningContent = document.getElementById('reasoning-content');
                
                if (!reasoningArea) {
                    console.error('âŒ ai-reasoning element not found!');
                    return;
                }
                if (!reasoningContent) {
                    console.error('âŒ reasoning-content element not found!');
                    return;
                }
                
                console.log(`âœ… Found reasoning elements, showing reasoning box`);
                // Show the reasoning area
                reasoningArea.style.display = 'block';
                
                // Create new reasoning entry
                const entry = document.createElement('div');
                entry.className = 'reasoning-entry';
                
                const playerDiv = document.createElement('div');
                playerDiv.className = 'reasoning-player';
                playerDiv.textContent = player.name;
                
                const actionDiv = document.createElement('div');
                actionDiv.className = 'reasoning-action';
                actionDiv.textContent = action;
                
                const reasoningDiv = document.createElement('div');
                reasoningDiv.className = 'reasoning-text';
                reasoningDiv.textContent = reasoning;
                
                entry.appendChild(playerDiv);
                entry.appendChild(actionDiv);
                entry.appendChild(reasoningDiv);
                
                // Add to content (prepend to show most recent first)
                reasoningContent.insertBefore(entry, reasoningContent.firstChild);
                
                // Limit to last 10 entries to prevent overflow
                while (reasoningContent.children.length > 10) {
                    reasoningContent.removeChild(reasoningContent.lastChild);
                }
                
                // Scroll to top to show latest reasoning
                reasoningContent.scrollTop = 0;
            }

            clearAIReasoning() {
                const reasoningContent = document.getElementById('reasoning-content');
                reasoningContent.innerHTML = '';
                const reasoningArea = document.getElementById('ai-reasoning');
                reasoningArea.style.display = 'none';
            }

            validateCategoryChoice(chosenCategory, possibleScores, availableCategories) {
                // Ensure the category is actually available
                if (!availableCategories.includes(chosenCategory)) {
                    console.log(`âš ï¸ Invalid category ${chosenCategory}, choosing best available instead`);
                    return this.getBestCategory(possibleScores, availableCategories);
                }
                
                // Check for strategic mistakes and auto-correct them
                const currentScore = possibleScores[chosenCategory];
                
                // Rule 1: Never use Yahtzee for anything other than yahtzee category
                if (this.isYahtzee() && chosenCategory !== 'yahtzee' && availableCategories.includes('yahtzee')) {
                    return 'yahtzee';
                }
                
                // Rule 2: Never use Four of a Kind for three-of-a-kind when four-of-a-kind is available
                if (this.isFourOfAKind() && chosenCategory === 'three-of-a-kind' && availableCategories.includes('four-of-a-kind')) {
                    return 'four-of-a-kind';
                }
                
                // Rule 3: Never use Full House for three-of-a-kind when full-house is available
                if (this.isFullHouse() && chosenCategory === 'three-of-a-kind' && availableCategories.includes('full-house')) {
                    return 'full-house';
                }
                
                // Rule 4: Never use Large Straight for small-straight when large-straight is available
                if (this.isLargeStraight() && chosenCategory === 'small-straight' && availableCategories.includes('large-straight')) {
                    return 'large-straight';
                }
                
                // Rule 5: Don't choose categories that score 0 when better options exist
                if (currentScore === 0) {
                    const betterOptions = availableCategories.filter(cat => possibleScores[cat] > 0);
                    if (betterOptions.length > 0) {
                        return this.getBestCategory(possibleScores, betterOptions);
                    }
                }
                
                return chosenCategory; // Choice is valid
            }

            getBestCategory(possibleScores, availableCategories) {
                let bestCategory = availableCategories[0];
                let bestScore = possibleScores[bestCategory];
                
                availableCategories.forEach(category => {
                    if (possibleScores[category] > bestScore) {
                        bestScore = possibleScores[category];
                        bestCategory = category;
                    }
                });
                
                return bestCategory;
            }

            isFourOfAKind() {
                const counts = {};
                this.dice.forEach(die => counts[die] = (counts[die] || 0) + 1);
                return Math.max(...Object.values(counts)) >= 4;
            }

            isFullHouse() {
                const counts = {};
                this.dice.forEach(die => counts[die] = (counts[die] || 0) + 1);
                const countValues = Object.values(counts).sort();
                return (countValues.length === 2 && countValues[0] === 2 && countValues[1] === 3);
            }

            isLargeStraight() {
                const uniqueDice = [...new Set(this.dice)].sort((a, b) => a - b);
                const largeStraights = [[1,2,3,4,5], [2,3,4,5,6]];
                return largeStraights.some(straight => 
                    straight.every(num => uniqueDice.includes(num)) && uniqueDice.length === 5);
            }

            autoPlayChooseCategory(player) {
                const availableCategories = this.getAvailableCategories(player);
                const scores = {};
                
                // Calculate scores for all available categories
                availableCategories.forEach(category => {
                    scores[category] = this.scoreCategory(category);
                });
                
                console.log(`${player.name} - Available category scores:`, scores);
                
                // Strategic category selection with priorities
                const strategy = this.analyzeScoreCardNeeds(availableCategories, player);
                
                // 1. Always take high-value categories when available
                const highValueCategories = ['yahtzee', 'large-straight', 'full-house'];
                for (let category of highValueCategories) {
                    if (availableCategories.includes(category) && scores[category] > 0) {
                        console.log(`${player.name} prioritizes high-value category: ${category} (${scores[category]} points)`);
                        return {category: category, score: scores[category]};
                    }
                }
                
                // 2. If we need upper section bonus, prioritize upper section when scores are decent
                if (strategy.needUpperSection && strategy.upperSectionProgress < 63) {
                    const upperCategories = ['sixes', 'fives', 'fours', 'threes', 'twos', 'ones'];
                    for (let category of upperCategories) {
                        if (availableCategories.includes(category)) {
                            const score = scores[category];
                            const minAcceptableScore = this.getMinAcceptableUpperScore(category);
                            
                            if (score >= minAcceptableScore) {
                                console.log(`${player.name} takes ${category} for upper section: ${score} points (min: ${minAcceptableScore})`);
                                return {category: category, score: score};
                            }
                        }
                    }
                }
                
                // 3. Take any category with good score
                let bestCategory = null;
                let bestScore = -1;
                
                availableCategories.forEach(category => {
                    const score = scores[category];
                    const minAcceptable = this.getMinAcceptableScore(category);
                    
                    if (score >= minAcceptable && score > bestScore) {
                        bestScore = score;
                        bestCategory = category;
                    }
                });
                
                if (bestCategory) {
                    console.log(`${player.name} takes best available: ${bestCategory} (${bestScore} points)`);
                    return {category: bestCategory, score: bestScore};
                }
                
                // 4. Fallback: Take the category with the highest score, even if low
                bestCategory = availableCategories[0];
                bestScore = scores[bestCategory];
                
                availableCategories.forEach(category => {
                    if (scores[category] > bestScore) {
                        bestScore = scores[category];
                        bestCategory = category;
                    }
                });
                
                console.log(`${player.name} forced to take: ${bestCategory} (${bestScore} points)`);
                return {category: bestCategory, score: bestScore};
            }

            getMinAcceptableUpperScore(category) {
                // Minimum acceptable scores for upper section categories
                const minimums = {
                    'ones': 2,    // At least 2 ones
                    'twos': 4,    // At least 2 twos  
                    'threes': 6,  // At least 2 threes
                    'fours': 8,   // At least 2 fours
                    'fives': 10,  // At least 2 fives
                    'sixes': 12   // At least 2 sixes
                };
                return minimums[category] || 0;
            }

            getMinAcceptableScore(category) {
                // Minimum scores worth taking for each category
                const minimums = {
                    'ones': 2, 'twos': 4, 'threes': 6, 'fours': 8, 'fives': 10, 'sixes': 12,
                    'three-of-a-kind': 15,
                    'four-of-a-kind': 20,
                    'full-house': 25,
                    'small-straight': 30,
                    'large-straight': 40,
                    'yahtzee': 50,
                    'chance': 15
                };
                return minimums[category] || 0;
            }

            async startMultiPlayerAutoPlay() {
                if (this.isAutoPlaying) return;
                
                this.isAutoPlaying = true;
                this.currentRound = 0;
                
                const autoPlayBtn = document.getElementById('auto-play-btn');
                autoPlayBtn.textContent = 'â¸ï¸ Stop Battle';
                autoPlayBtn.onclick = () => this.stopAutoPlay();
                
                // Reset all player scorecards
                this.players.forEach(player => {
                    player.scorecard = {};
                    player.currentRound = 0;
                });
                this.initializeScoreCards();
                
                // Clear previous AI reasoning
                this.clearAIReasoning();
                
                console.log('Starting multi-player auto-play with 4 AI players');
                
                // Play 13 rounds (complete game)
                for (let round = 0; round < 13 && this.isAutoPlaying; round++) {
                    console.log(`\n=== ROUND ${round + 1} ===`);
                    
                    // Each player takes a turn
                    for (let playerIndex = 0; playerIndex < this.players.length && this.isAutoPlaying; playerIndex++) {
                        const player = this.players[playerIndex];
                        console.log(`\n--- ${player.name}'s turn ---`);
                        
                        this.setActivePlayer(player);
                        await this.playPlayerTurn(player);
                        
                        // Longer delay between players to prevent rate limiting
                        await this.delay(2000);
                    }
                    
                    // Even longer delay between rounds
                    await this.delay(3000);
                }
                
                if (this.isAutoPlaying) {
                    this.stopAutoPlay();
                    this.showFinalMultiPlayerResults();
                }
            }

            async playPlayerTurn(player) {
                const availableCategories = this.getAvailableCategories(player);
                if (availableCategories.length === 0) {
                    console.log(`${player.name} has completed all categories`);
                    return;
                }
                
                // Reset turn state
                this.resetTurn();
                
                // Play up to 3 turns for this player
                for (let turn = 1; turn <= 3 && this.isAutoPlaying; turn++) {
                    console.log(`${player.name} - turn ${turn}`);
                    
                    // Roll dice
                    await this.autoRollDice();
                    
                    // Wait to see the result
                    await this.delay(1000);
                    
                    if (turn < 3) {
                        // AI decides what to hold (use LLM for LLM players)
                        let holdDecision;
                        if (player.strategy.startsWith('llm-') && this.useLLM) {
                            console.log(`${player.name} thinking with ChatGPT...`);
                            // Add delay before API call to prevent rate limiting
                            console.log(`â³ Waiting 2 seconds to prevent API rate limiting...`);
                            await this.delay(2000);
                            holdDecision = await this.llmDecideHold(player);
                            // Add delay after API call
                            await this.delay(1000);
                        } else {
                            holdDecision = this.autoPlayDecideHold(player);
                            // Show traditional AI reasoning with actual decision
                            const heldDice = this.dice.filter((die, index) => holdDecision[index]);
                            const notHeldDice = this.dice.filter((die, index) => !holdDecision[index]);
                            const reasoning = `Using rule-based AI strategy for dice holding\n\nðŸŽ² Actually holding: [${heldDice.join(', ')}]\nðŸ”„ Will reroll: [${notHeldDice.join(', ')}]`;
                            this.showAIReasoning(player, `ðŸŽª Traditional AI Hold Decision (Turn ${this.turn})`, reasoning);
                        }
                        
                        this.heldDice = holdDecision;
                        this.updateDisplay();
                        
                        // Show what AI is holding
                        await this.delay(1200);
                    }
                }
                
                // Choose category and score (use LLM for LLM players)
                let choice;
                if (player.strategy.startsWith('llm-') && this.useLLM) {
                    console.log(`${player.name} choosing category with ChatGPT...`);
                    // Add delay before API call to prevent rate limiting
                    console.log(`â³ Waiting 2 seconds to prevent API rate limiting...`);
                    await this.delay(2000);
                    choice = await this.llmChooseCategory(player);
                    // Add delay after API call
                    await this.delay(1000);
                } else {
                    choice = this.autoPlayChooseCategory(player);
                    // Show traditional AI reasoning with strategy explanation
                    const reasoning = `Used rule-based AI to select highest scoring available category\n\nSelected: ${choice.category} (${choice.score} points)\nStrategy: Traditional AI prioritizes highest immediate score`;
                    this.showAIReasoning(player, `ðŸŽª Traditional AI Category Selection: ${choice.category} (${choice.score} pts)`, reasoning);
                }
                console.log(`${player.name} chooses ${choice.category} for ${choice.score} points`);
                
                // Fill scorecard for this player
                this.fillScorecard(player, choice.category, choice.score);
                
                await this.delay(800);
            }

            showFinalMultiPlayerResults() {
                console.log('\n=== FINAL RESULTS ===');
                const results = this.players.map(player => {
                    const totalScore = this.calculatePlayerTotalScore(player);
                    console.log(`${player.name}: ${totalScore} points`);
                    return { player, totalScore };
                }).sort((a, b) => b.totalScore - a.totalScore);
                
                const winner = results[0];
                console.log(`ðŸ† WINNER: ${winner.player.name} with ${winner.totalScore} points!`);
                
                // Show results in UI
                alert(`ðŸ† Game Complete!\n\nWINNER: ${winner.player.name} (${winner.totalScore} points)\n\n` +
                      results.map((r, i) => `${i + 1}. ${r.player.name}: ${r.totalScore} points`).join('\n'));
            }

            calculatePlayerTotalScore(player) {
                const upperCategories = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'];
                let upperTotal = 0;
                
                upperCategories.forEach(category => {
                    if (player.scorecard[category] !== undefined) {
                        upperTotal += player.scorecard[category];
                    }
                });
                
                // Upper section bonus
                const bonus = upperTotal >= 63 ? 35 : 0;
                
                // Calculate total score
                let totalScore = upperTotal + bonus;
                const lowerCategories = ['three-of-a-kind', 'four-of-a-kind', 'full-house', 
                                       'small-straight', 'large-straight', 'yahtzee', 'chance'];
                
                lowerCategories.forEach(category => {
                    if (player.scorecard[category] !== undefined) {
                        totalScore += player.scorecard[category];
                    }
                });
                
                return totalScore;
            }

            async startAutoPlay() {
                // Start multi-player mode instead
                await this.startMultiPlayerAutoPlay();
            }

            async playAutoRound() {
                console.log(`Starting auto-play round ${this.currentRound + 1}`);
                
                // Highlight current turn in scorecard
                document.querySelectorAll('tr[data-category]').forEach(row => {
                    row.classList.remove('current-turn');
                });
                
                this.resetTurn();
                
                // Play up to 3 turns
                for (let turn = 1; turn <= 3 && this.isAutoPlaying; turn++) {
                    console.log(`Auto-play turn ${turn}`);
                    
                    // Roll dice
                    await this.autoRollDice();
                    
                    // Wait to see the result
                    await this.delay(1000);
                    
                    if (turn < 3) {
                        // AI decides what to hold
                        const holdDecision = this.autoPlayDecideHold();
                        this.heldDice = holdDecision;
                        this.updateDisplay();
                        
                        // Show what AI is holding
                        await this.delay(1500);
                    }
                }
                
                // Choose category and score
                const choice = this.autoPlayChooseCategory();
                console.log(`AI chooses ${choice.category} for ${choice.score} points`);
                
                // Highlight the chosen category
                const categoryRow = document.querySelector(`tr[data-category="${choice.category}"]`);
                categoryRow.classList.add('current-turn');
                
                await this.delay(1000);
                
                this.fillScorecard(choice.category, choice.score);
                categoryRow.classList.remove('current-turn');
                
                await this.delay(1500);
            }

            async autoRollDice() {
                return new Promise((resolve) => {
                    // Use the existing roll dice logic but return a promise
                    this.rollDice();
                    
                    // Wait for the longest possible dice animation
                    setTimeout(resolve, 3500);
                });
            }

            stopAutoPlay() {
                this.isAutoPlaying = false;
                const autoPlayBtn = document.getElementById('auto-play-btn');
                autoPlayBtn.textContent = 'ðŸ§  GPT-4 vs AI Battle';
                autoPlayBtn.onclick = () => this.startAutoPlay();
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            resetTurn() {
                this.turn = 0;
                this.heldDice = [false, false, false, false, false];
                this.suggestedDice = [false, false, false, false, false];
                this.dice = [0, 0, 0, 0, 0];
                this.gameStarted = true;
            }

            updateDisplay() {
                // Generate suggestions first if we have dice rolled
                let suggestion = "";
                if (this.turn > 0 && this.turn < this.maxTurns) {
                    suggestion = this.analyzeDice();
                }
                
                // Update dice display
                for (let i = 0; i < 5; i++) {
                    const dieElement = document.getElementById(`die-${i}`);
                    
                    // Don't update if currently rolling
                    if (dieElement.classList.contains('rolling')) {
                        continue;
                    }
                    
                    if (this.dice[i] > 0) {
                        this.setDiceFace(dieElement, this.dice[i]);
                    }
                    
                    // Remove state classes but preserve face classes
                    dieElement.classList.remove('held', 'suggested');
                    
                    // Add appropriate classes - held takes priority over suggested
                    if (this.heldDice[i]) {
                        dieElement.classList.add('held');
                    } else if (this.suggestedDice[i] && this.turn > 0 && this.turn < this.maxTurns) {
                        dieElement.classList.add('suggested');
                    }
                }

                // Update turn info and hints
                const turnInfo = document.getElementById('turn-info');
                const hints = document.getElementById('hints');
                const hintText = document.getElementById('hint-text');
                
                if (this.turn === 0) {
                    turnInfo.textContent = 'Click "Roll Dice" to start your first roll!';
                    hints.style.display = 'none';
                } else if (this.turn < this.maxTurns) {
                    turnInfo.textContent = `Turn ${this.turn} of ${this.maxTurns} - Orange dice are suggested to keep`;
                    hintText.textContent = suggestion;
                    hints.style.display = 'block';
                } else {
                    turnInfo.textContent = 'Round complete!';
                    hints.style.display = 'none';
                    this.showFinalResult();
                }

                // Update button states
                const rollBtn = document.getElementById('roll-btn');
                if (this.turn >= this.maxTurns) {
                    rollBtn.disabled = true;
                    rollBtn.textContent = 'Round Complete';
                } else {
                    rollBtn.disabled = false;
                    rollBtn.textContent = this.turn === 0 ? 'Roll Dice' : 'Roll Again';
                }
            }

            showFinalResult() {
                const finalResult = document.getElementById('final-result');
                const finalDice = document.getElementById('final-dice');
                const sortedDice = document.getElementById('sorted-dice');
                
                const bestScore = this.getBestScore();
                const allScores = this.calculateYahtzeeScores();
                
                finalDice.textContent = `Final dice: ${this.dice.join(', ')}`;
                sortedDice.textContent = `Sorted: ${[...this.dice].sort((a, b) => a - b).join(', ')}`;
                
                // Add best score display
                const bestScoreDiv = document.getElementById('best-score') || this.createBestScoreDiv();
                bestScoreDiv.innerHTML = `
                    <strong>ðŸ† Best Score: ${bestScore.score} points (${bestScore.category})</strong>
                    <br><br>
                    <details>
                        <summary>All possible scores:</summary>
                        <div style="margin-top: 10px; text-align: left;">
                            ${this.formatAllScores(allScores)}
                        </div>
                    </details>
                `;
                
                finalResult.style.display = 'block';
            }

            createBestScoreDiv() {
                const bestScoreDiv = document.createElement('div');
                bestScoreDiv.id = 'best-score';
                bestScoreDiv.className = 'dice-values';
                bestScoreDiv.style.marginTop = '15px';
                document.getElementById('final-result').appendChild(bestScoreDiv);
                return bestScoreDiv;
            }

            formatAllScores(scores) {
                const categories = [
                    'Yahtzee', 'Large Straight', 'Small Straight', 'Full House',
                    'Four of a Kind', 'Three of a Kind', 'Chance',
                    '6s', '5s', '4s', '3s', '2s', '1s'
                ];
                
                return categories
                    .filter(category => scores[category] > 0)
                    .map(category => `${category}: ${scores[category]} points`)
                    .join('<br>');
            }

            newGame() {
                this.dice = [0, 0, 0, 0, 0];
                this.heldDice = [false, false, false, false, false];
                this.suggestedDice = [false, false, false, false, false];
                this.turn = 0;
                this.gameStarted = true;
                this.scorecard = {};
                this.currentRound = 0;
                
                // Reset dice display
                for (let i = 0; i < 5; i++) {
                    const dieElement = document.getElementById(`die-${i}`);
                    dieElement.textContent = '?';
                    dieElement.classList.remove('held', 'suggested', 'rolling', 'shake');
                }
                
                // Reset scorecard display
                const allCategories = ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes',
                                     'three-of-a-kind', 'four-of-a-kind', 'full-house',
                                     'small-straight', 'large-straight', 'yahtzee', 'chance'];
                
                allCategories.forEach(category => {
                    document.getElementById(`score-${category}`).textContent = '-';
                    document.querySelector(`tr[data-category="${category}"]`).classList.remove('filled', 'current-turn');
                });
                
                document.getElementById('upper-subtotal').textContent = '0';
                document.getElementById('upper-bonus').textContent = '0';
                document.getElementById('total-score').textContent = '0';
                
                // Hide final result and hints
                document.getElementById('final-result').style.display = 'none';
                document.getElementById('hints').style.display = 'none';
                
                this.updateDisplay();
            }
        }

        // Initialize game
        const game = new YahtzeeGame();

        // Global functions for button clicks
        function rollDice() {
            game.rollDice();
        }

        function newGame() {
            game.newGame();
        }

        function startAutoPlay() {
            game.startAutoPlay();
        }



        // Add click listeners to dice
        for (let i = 0; i < 5; i++) {
            document.getElementById(`die-${i}`).addEventListener('click', () => {
                game.toggleHold(i);
            });
        }

        // Initialize display
        game.updateDisplay();
    </script>
</body>
</html>